/* soapC.cpp
   Generated by gSOAP 2.7.6c from atxml.h
   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.6c 2006-03-28 15:47:04 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_SOAP_ENV__Reason:
		return soap_in_SOAP_ENV__Reason(soap, NULL, NULL, "SOAP-ENV:Reason");
	case SOAP_TYPE_atxml__IssueDriverFunctionCall:
		return soap_in_atxml__IssueDriverFunctionCall(soap, NULL, NULL, "atxml:IssueDriverFunctionCall");
	case SOAP_TYPE_atxml__IssueDriverFunctionCallResponse:
		return soap_in_atxml__IssueDriverFunctionCallResponse(soap, NULL, NULL, "atxml:IssueDriverFunctionCallResponse");
	case SOAP_TYPE_atxml__IssueNativeCmds:
		return soap_in_atxml__IssueNativeCmds(soap, NULL, NULL, "atxml:IssueNativeCmds");
	case SOAP_TYPE_atxml__IssueNativeCmdsResponse:
		return soap_in_atxml__IssueNativeCmdsResponse(soap, NULL, NULL, "atxml:IssueNativeCmdsResponse");
	case SOAP_TYPE_atxml__IssueIst:
		return soap_in_atxml__IssueIst(soap, NULL, NULL, "atxml:IssueIst");
	case SOAP_TYPE_atxml__IssueIstResponse:
		return soap_in_atxml__IssueIstResponse(soap, NULL, NULL, "atxml:IssueIstResponse");
	case SOAP_TYPE_atxml__IssueTestResultsFile:
		return soap_in_atxml__IssueTestResultsFile(soap, NULL, NULL, "atxml:IssueTestResultsFile");
	case SOAP_TYPE_atxml__IssueTestResultsFileResponse:
		return soap_in_atxml__IssueTestResultsFileResponse(soap, NULL, NULL, "atxml:IssueTestResultsFileResponse");
	case SOAP_TYPE_atxml__IssueTestResults:
		return soap_in_atxml__IssueTestResults(soap, NULL, NULL, "atxml:IssueTestResults");
	case SOAP_TYPE_atxml__IssueTestResultsResponse:
		return soap_in_atxml__IssueTestResultsResponse(soap, NULL, NULL, "atxml:IssueTestResultsResponse");
	case SOAP_TYPE_atxml__InvokeRemoveAllSequence:
		return soap_in_atxml__InvokeRemoveAllSequence(soap, NULL, NULL, "atxml:InvokeRemoveAllSequence");
	case SOAP_TYPE_atxml__InvokeRemoveAllSequenceResponse:
		return soap_in_atxml__InvokeRemoveAllSequenceResponse(soap, NULL, NULL, "atxml:InvokeRemoveAllSequenceResponse");
	case SOAP_TYPE_atxml__InvokeApplyAllSequence:
		return soap_in_atxml__InvokeApplyAllSequence(soap, NULL, NULL, "atxml:InvokeApplyAllSequence");
	case SOAP_TYPE_atxml__InvokeApplyAllSequenceResponse:
		return soap_in_atxml__InvokeApplyAllSequenceResponse(soap, NULL, NULL, "atxml:InvokeApplyAllSequenceResponse");
	case SOAP_TYPE_atxml__QueryInterStatus:
		return soap_in_atxml__QueryInterStatus(soap, NULL, NULL, "atxml:QueryInterStatus");
	case SOAP_TYPE_atxml__QueryInterStatusResponse:
		return soap_in_atxml__QueryInterStatusResponse(soap, NULL, NULL, "atxml:QueryInterStatusResponse");
	case SOAP_TYPE_atxml__IssueSignal:
		return soap_in_atxml__IssueSignal(soap, NULL, NULL, "atxml:IssueSignal");
	case SOAP_TYPE_atxml__IssueSignalResponse:
		return soap_in_atxml__IssueSignalResponse(soap, NULL, NULL, "atxml:IssueSignalResponse");
	case SOAP_TYPE_atxml__SubmitUutId:
		return soap_in_atxml__SubmitUutId(soap, NULL, NULL, "atxml:SubmitUutId");
	case SOAP_TYPE_atxml__SubmitUutIdResponse:
		return soap_in_atxml__SubmitUutIdResponse(soap, NULL, NULL, "atxml:SubmitUutIdResponse");
	case SOAP_TYPE_atxml__RegisterTmaSelect:
		return soap_in_atxml__RegisterTmaSelect(soap, NULL, NULL, "atxml:RegisterTmaSelect");
	case SOAP_TYPE_atxml__RegisterTmaSelectResponse:
		return soap_in_atxml__RegisterTmaSelectResponse(soap, NULL, NULL, "atxml:RegisterTmaSelectResponse");
	case SOAP_TYPE_atxml__RegisterInstStatus:
		return soap_in_atxml__RegisterInstStatus(soap, NULL, NULL, "atxml:RegisterInstStatus");
	case SOAP_TYPE_atxml__RegisterInstStatusResponse:
		return soap_in_atxml__RegisterInstStatusResponse(soap, NULL, NULL, "atxml:RegisterInstStatusResponse");
	case SOAP_TYPE_atxml__TestStationStatus:
		return soap_in_atxml__TestStationStatus(soap, NULL, NULL, "atxml:TestStationStatus");
	case SOAP_TYPE_atxml__TestStationStatusResponse:
		return soap_in_atxml__TestStationStatusResponse(soap, NULL, NULL, "atxml:TestStationStatusResponse");
	case SOAP_TYPE_atxml__RegisterRemoveSequence:
		return soap_in_atxml__RegisterRemoveSequence(soap, NULL, NULL, "atxml:RegisterRemoveSequence");
	case SOAP_TYPE_atxml__RegisterRemoveSequenceResponse:
		return soap_in_atxml__RegisterRemoveSequenceResponse(soap, NULL, NULL, "atxml:RegisterRemoveSequenceResponse");
	case SOAP_TYPE_atxml__RegisterApplySequence:
		return soap_in_atxml__RegisterApplySequence(soap, NULL, NULL, "atxml:RegisterRemoveSequence");
	case SOAP_TYPE_atxml__RegisterApplySequenceResponse:
		return soap_in_atxml__RegisterApplySequenceResponse(soap, NULL, NULL, "atxml:RegisterApplySequenceResponse");
	case SOAP_TYPE_atxml__ValidateRequirements:
		return soap_in_atxml__ValidateRequirements(soap, NULL, NULL, "atxml:ValidateRequirements");
	case SOAP_TYPE_atxml__ValidateRequirementsResponse:
		return soap_in_atxml__ValidateRequirementsResponse(soap, NULL, NULL, "atxml:ValidateRequirementsResponse");
	case SOAP_TYPE_atxml__RegisterTSF:
		return soap_in_atxml__RegisterTSF(soap, NULL, NULL, "atxml:RegisterTSF");
	case SOAP_TYPE_atxml__RegisterTSFResponse:
		return soap_in_atxml__RegisterTSFResponse(soap, NULL, NULL, "atxml:RegisterTSFResponse");
	case SOAP_TYPE_atxml__RetrieveTpsData:
		return soap_in_atxml__RetrieveTpsData(soap, NULL, NULL, "atxml:RetrieveTpsData");
	case SOAP_TYPE_atxml__RetrieveTpsDataResponse:
		return soap_in_atxml__RetrieveTpsDataResponse(soap, NULL, NULL, "atxml:RetrieveTpsDataResponse");
	case SOAP_TYPE_atxml__RegisterInterUsed:
		return soap_in_atxml__RegisterInterUsed(soap, NULL, NULL, "atxml:RegisterInterUsed");
	case SOAP_TYPE_atxml__RegisterInterUsedResponse:
		return soap_in_atxml__RegisterInterUsedResponse(soap, NULL, NULL, "atxml:RegisterInterUsedResponse");
	case SOAP_TYPE_atxml__Close:
		return soap_in_atxml__Close(soap, NULL, NULL, "atxml:Close");
	case SOAP_TYPE_atxml__CloseResponse:
		return soap_in_atxml__CloseResponse(soap, NULL, NULL, "atxml:CloseResponse");
	case SOAP_TYPE_atxml__Initialize:
		return soap_in_atxml__Initialize(soap, NULL, NULL, "atxml:Initialize");
	case SOAP_TYPE_atxml__InitializeResponse:
		return soap_in_atxml__InitializeResponse(soap, NULL, NULL, "atxml:InitializeResponse");
	case SOAP_TYPE_PointerToSOAP_ENV__Reason:
		return soap_in_PointerToSOAP_ENV__Reason(soap, NULL, NULL, "SOAP-ENV:Reason");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__string:
	{	char **s;
		s = soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENV:Reason"))
		{	*type = SOAP_TYPE_SOAP_ENV__Reason;
			return soap_in_SOAP_ENV__Reason(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueDriverFunctionCall"))
		{	*type = SOAP_TYPE_atxml__IssueDriverFunctionCall;
			return soap_in_atxml__IssueDriverFunctionCall(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueDriverFunctionCallResponse"))
		{	*type = SOAP_TYPE_atxml__IssueDriverFunctionCallResponse;
			return soap_in_atxml__IssueDriverFunctionCallResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueNativeCmds"))
		{	*type = SOAP_TYPE_atxml__IssueNativeCmds;
			return soap_in_atxml__IssueNativeCmds(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueNativeCmdsResponse"))
		{	*type = SOAP_TYPE_atxml__IssueNativeCmdsResponse;
			return soap_in_atxml__IssueNativeCmdsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueIst"))
		{	*type = SOAP_TYPE_atxml__IssueIst;
			return soap_in_atxml__IssueIst(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueIstResponse"))
		{	*type = SOAP_TYPE_atxml__IssueIstResponse;
			return soap_in_atxml__IssueIstResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueTestResultsFile"))
		{	*type = SOAP_TYPE_atxml__IssueTestResultsFile;
			return soap_in_atxml__IssueTestResultsFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueTestResultsFileResponse"))
		{	*type = SOAP_TYPE_atxml__IssueTestResultsFileResponse;
			return soap_in_atxml__IssueTestResultsFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueTestResults"))
		{	*type = SOAP_TYPE_atxml__IssueTestResults;
			return soap_in_atxml__IssueTestResults(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueTestResultsResponse"))
		{	*type = SOAP_TYPE_atxml__IssueTestResultsResponse;
			return soap_in_atxml__IssueTestResultsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:InvokeRemoveAllSequence"))
		{	*type = SOAP_TYPE_atxml__InvokeRemoveAllSequence;
			return soap_in_atxml__InvokeRemoveAllSequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:InvokeRemoveAllSequenceResponse"))
		{	*type = SOAP_TYPE_atxml__InvokeRemoveAllSequenceResponse;
			return soap_in_atxml__InvokeRemoveAllSequenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:InvokeApplyAllSequence"))
		{	*type = SOAP_TYPE_atxml__InvokeApplyAllSequence;
			return soap_in_atxml__InvokeApplyAllSequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:InvokeApplyAllSequenceResponse"))
		{	*type = SOAP_TYPE_atxml__InvokeApplyAllSequenceResponse;
			return soap_in_atxml__InvokeApplyAllSequenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:QueryInterStatus"))
		{	*type = SOAP_TYPE_atxml__QueryInterStatus;
			return soap_in_atxml__QueryInterStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:QueryInterStatusResponse"))
		{	*type = SOAP_TYPE_atxml__QueryInterStatusResponse;
			return soap_in_atxml__QueryInterStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueSignal"))
		{	*type = SOAP_TYPE_atxml__IssueSignal;
			return soap_in_atxml__IssueSignal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:IssueSignalResponse"))
		{	*type = SOAP_TYPE_atxml__IssueSignalResponse;
			return soap_in_atxml__IssueSignalResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:SubmitUutId"))
		{	*type = SOAP_TYPE_atxml__SubmitUutId;
			return soap_in_atxml__SubmitUutId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:SubmitUutIdResponse"))
		{	*type = SOAP_TYPE_atxml__SubmitUutIdResponse;
			return soap_in_atxml__SubmitUutIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterTmaSelect"))
		{	*type = SOAP_TYPE_atxml__RegisterTmaSelect;
			return soap_in_atxml__RegisterTmaSelect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterTmaSelectResponse"))
		{	*type = SOAP_TYPE_atxml__RegisterTmaSelectResponse;
			return soap_in_atxml__RegisterTmaSelectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterInstStatus"))
		{	*type = SOAP_TYPE_atxml__RegisterInstStatus;
			return soap_in_atxml__RegisterInstStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterInstStatusResponse"))
		{	*type = SOAP_TYPE_atxml__RegisterInstStatusResponse;
			return soap_in_atxml__RegisterInstStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:TestStationStatus"))
		{	*type = SOAP_TYPE_atxml__TestStationStatus;
			return soap_in_atxml__TestStationStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:TestStationStatusResponse"))
		{	*type = SOAP_TYPE_atxml__TestStationStatusResponse;
			return soap_in_atxml__TestStationStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterRemoveSequence"))
		{	*type = SOAP_TYPE_atxml__RegisterRemoveSequence;
			return soap_in_atxml__RegisterRemoveSequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterRemoveSequenceResponse"))
		{	*type = SOAP_TYPE_atxml__RegisterRemoveSequenceResponse;
			return soap_in_atxml__RegisterRemoveSequenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterApplySequence"))
		{	*type = SOAP_TYPE_atxml__RegisterApplySequence;
			return soap_in_atxml__RegisterApplySequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterApplySequenceResponse"))
		{	*type = SOAP_TYPE_atxml__RegisterApplySequenceResponse;
			return soap_in_atxml__RegisterApplySequenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:ValidateRequirements"))
		{	*type = SOAP_TYPE_atxml__ValidateRequirements;
			return soap_in_atxml__ValidateRequirements(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:ValidateRequirementsResponse"))
		{	*type = SOAP_TYPE_atxml__ValidateRequirementsResponse;
			return soap_in_atxml__ValidateRequirementsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterTSF"))
		{	*type = SOAP_TYPE_atxml__RegisterTSF;
			return soap_in_atxml__RegisterTSF(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterTSFResponse"))
		{	*type = SOAP_TYPE_atxml__RegisterTSFResponse;
			return soap_in_atxml__RegisterTSFResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RetrieveTpsData"))
		{	*type = SOAP_TYPE_atxml__RetrieveTpsData;
			return soap_in_atxml__RetrieveTpsData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RetrieveTpsDataResponse"))
		{	*type = SOAP_TYPE_atxml__RetrieveTpsDataResponse;
			return soap_in_atxml__RetrieveTpsDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterInterUsed"))
		{	*type = SOAP_TYPE_atxml__RegisterInterUsed;
			return soap_in_atxml__RegisterInterUsed(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:RegisterInterUsedResponse"))
		{	*type = SOAP_TYPE_atxml__RegisterInterUsedResponse;
			return soap_in_atxml__RegisterInterUsedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:Close"))
		{	*type = SOAP_TYPE_atxml__Close;
			return soap_in_atxml__Close(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:CloseResponse"))
		{	*type = SOAP_TYPE_atxml__CloseResponse;
			return soap_in_atxml__CloseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:Initialize"))
		{	*type = SOAP_TYPE_atxml__Initialize;
			return soap_in_atxml__Initialize(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "atxml:InitializeResponse"))
		{	*type = SOAP_TYPE_atxml__InitializeResponse;
			return soap_in_atxml__InitializeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_xsd__string;
			s = soap_in_xsd__string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
			return soap->error = SOAP_TAG_MISMATCH;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_SOAP_ENV__Reason:
		return soap_out_SOAP_ENV__Reason(soap, tag, id, (const struct SOAP_ENV__Reason *)ptr, "SOAP-ENV:Reason");
	case SOAP_TYPE_atxml__IssueDriverFunctionCall:
		return soap_out_atxml__IssueDriverFunctionCall(soap, tag, id, (const struct atxml__IssueDriverFunctionCall *)ptr, "atxml:IssueDriverFunctionCall");
	case SOAP_TYPE_atxml__IssueDriverFunctionCallResponse:
		return soap_out_atxml__IssueDriverFunctionCallResponse(soap, tag, id, (const struct atxml__IssueDriverFunctionCallResponse *)ptr, "atxml:IssueDriverFunctionCallResponse");
	case SOAP_TYPE_atxml__IssueNativeCmds:
		return soap_out_atxml__IssueNativeCmds(soap, tag, id, (const struct atxml__IssueNativeCmds *)ptr, "atxml:IssueNativeCmds");
	case SOAP_TYPE_atxml__IssueNativeCmdsResponse:
		return soap_out_atxml__IssueNativeCmdsResponse(soap, tag, id, (const struct atxml__IssueNativeCmdsResponse *)ptr, "atxml:IssueNativeCmdsResponse");
	case SOAP_TYPE_atxml__IssueIst:
		return soap_out_atxml__IssueIst(soap, tag, id, (const struct atxml__IssueIst *)ptr, "atxml:IssueIst");
	case SOAP_TYPE_atxml__IssueIstResponse:
		return soap_out_atxml__IssueIstResponse(soap, tag, id, (const struct atxml__IssueIstResponse *)ptr, "atxml:IssueIstResponse");
	case SOAP_TYPE_atxml__IssueTestResultsFile:
		return soap_out_atxml__IssueTestResultsFile(soap, tag, id, (const struct atxml__IssueTestResultsFile *)ptr, "atxml:IssueTestResultsFile");
	case SOAP_TYPE_atxml__IssueTestResultsFileResponse:
		return soap_out_atxml__IssueTestResultsFileResponse(soap, tag, id, (const struct atxml__IssueTestResultsFileResponse *)ptr, "atxml:IssueTestResultsFileResponse");
	case SOAP_TYPE_atxml__IssueTestResults:
		return soap_out_atxml__IssueTestResults(soap, tag, id, (const struct atxml__IssueTestResults *)ptr, "atxml:IssueTestResults");
	case SOAP_TYPE_atxml__IssueTestResultsResponse:
		return soap_out_atxml__IssueTestResultsResponse(soap, tag, id, (const struct atxml__IssueTestResultsResponse *)ptr, "atxml:IssueTestResultsResponse");
	case SOAP_TYPE_atxml__InvokeRemoveAllSequence:
		return soap_out_atxml__InvokeRemoveAllSequence(soap, tag, id, (const struct atxml__InvokeRemoveAllSequence *)ptr, "atxml:InvokeRemoveAllSequence");
	case SOAP_TYPE_atxml__InvokeRemoveAllSequenceResponse:
		return soap_out_atxml__InvokeRemoveAllSequenceResponse(soap, tag, id, (const struct atxml__InvokeRemoveAllSequenceResponse *)ptr, "atxml:InvokeRemoveAllSequenceResponse");
	case SOAP_TYPE_atxml__InvokeApplyAllSequence:
		return soap_out_atxml__InvokeApplyAllSequence(soap, tag, id, (const struct atxml__InvokeApplyAllSequence *)ptr, "atxml:InvokeApplyAllSequence");
	case SOAP_TYPE_atxml__InvokeApplyAllSequenceResponse:
		return soap_out_atxml__InvokeApplyAllSequenceResponse(soap, tag, id, (const struct atxml__InvokeApplyAllSequenceResponse *)ptr, "atxml:InvokeApplyAllSequenceResponse");
	case SOAP_TYPE_atxml__QueryInterStatus:
		return soap_out_atxml__QueryInterStatus(soap, tag, id, (const struct atxml__QueryInterStatus *)ptr, "atxml:QueryInterStatus");
	case SOAP_TYPE_atxml__QueryInterStatusResponse:
		return soap_out_atxml__QueryInterStatusResponse(soap, tag, id, (const struct atxml__QueryInterStatusResponse *)ptr, "atxml:QueryInterStatusResponse");
	case SOAP_TYPE_atxml__IssueSignal:
		return soap_out_atxml__IssueSignal(soap, tag, id, (const struct atxml__IssueSignal *)ptr, "atxml:IssueSignal");
	case SOAP_TYPE_atxml__IssueSignalResponse:
		return soap_out_atxml__IssueSignalResponse(soap, tag, id, (const struct atxml__IssueSignalResponse *)ptr, "atxml:IssueSignalResponse");
	case SOAP_TYPE_atxml__SubmitUutId:
		return soap_out_atxml__SubmitUutId(soap, tag, id, (const struct atxml__SubmitUutId *)ptr, "atxml:SubmitUutId");
	case SOAP_TYPE_atxml__SubmitUutIdResponse:
		return soap_out_atxml__SubmitUutIdResponse(soap, tag, id, (const struct atxml__SubmitUutIdResponse *)ptr, "atxml:SubmitUutIdResponse");
	case SOAP_TYPE_atxml__RegisterTmaSelect:
		return soap_out_atxml__RegisterTmaSelect(soap, tag, id, (const struct atxml__RegisterTmaSelect *)ptr, "atxml:RegisterTmaSelect");
	case SOAP_TYPE_atxml__RegisterTmaSelectResponse:
		return soap_out_atxml__RegisterTmaSelectResponse(soap, tag, id, (const struct atxml__RegisterTmaSelectResponse *)ptr, "atxml:RegisterTmaSelectResponse");
	case SOAP_TYPE_atxml__RegisterInstStatus:
		return soap_out_atxml__RegisterInstStatus(soap, tag, id, (const struct atxml__RegisterInstStatus *)ptr, "atxml:RegisterInstStatus");
	case SOAP_TYPE_atxml__RegisterInstStatusResponse:
		return soap_out_atxml__RegisterInstStatusResponse(soap, tag, id, (const struct atxml__RegisterInstStatusResponse *)ptr, "atxml:RegisterInstStatusResponse");
	case SOAP_TYPE_atxml__TestStationStatus:
		return soap_out_atxml__TestStationStatus(soap, tag, id, (const struct atxml__TestStationStatus *)ptr, "atxml:TestStationStatus");
	case SOAP_TYPE_atxml__TestStationStatusResponse:
		return soap_out_atxml__TestStationStatusResponse(soap, tag, id, (const struct atxml__TestStationStatusResponse *)ptr, "atxml:TestStationStatusResponse");
	case SOAP_TYPE_atxml__RegisterRemoveSequence:
		return soap_out_atxml__RegisterRemoveSequence(soap, tag, id, (const struct atxml__RegisterRemoveSequence *)ptr, "atxml:RegisterRemoveSequence");
	case SOAP_TYPE_atxml__RegisterRemoveSequenceResponse:
		return soap_out_atxml__RegisterRemoveSequenceResponse(soap, tag, id, (const struct atxml__RegisterRemoveSequenceResponse *)ptr, "atxml:RegisterRemoveSequenceResponse");
	case SOAP_TYPE_atxml__RegisterApplySequence:
		return soap_out_atxml__RegisterApplySequence(soap, tag, id, (const struct atxml__RegisterApplySequence *)ptr, "atxml:RegisterApplySequence");
	case SOAP_TYPE_atxml__RegisterApplySequenceResponse:
		return soap_out_atxml__RegisterApplySequenceResponse(soap, tag, id, (const struct atxml__RegisterApplySequenceResponse *)ptr, "atxml:RegisterApplySequenceResponse");
	case SOAP_TYPE_atxml__ValidateRequirements:
		return soap_out_atxml__ValidateRequirements(soap, tag, id, (const struct atxml__ValidateRequirements *)ptr, "atxml:ValidateRequirements");
	case SOAP_TYPE_atxml__ValidateRequirementsResponse:
		return soap_out_atxml__ValidateRequirementsResponse(soap, tag, id, (const struct atxml__ValidateRequirementsResponse *)ptr, "atxml:ValidateRequirementsResponse");
	case SOAP_TYPE_atxml__RegisterTSF:
		return soap_out_atxml__RegisterTSF(soap, tag, id, (const struct atxml__RegisterTSF *)ptr, "atxml:RegisterTSF");
	case SOAP_TYPE_atxml__RegisterTSFResponse:
		return soap_out_atxml__RegisterTSFResponse(soap, tag, id, (const struct atxml__RegisterTSFResponse *)ptr, "atxml:RegisterTSFResponse");
	case SOAP_TYPE_atxml__RetrieveTpsData:
		return soap_out_atxml__RetrieveTpsData(soap, tag, id, (const struct atxml__RetrieveTpsData *)ptr, "atxml:RetrieveTpsData");
	case SOAP_TYPE_atxml__RetrieveTpsDataResponse:
		return soap_out_atxml__RetrieveTpsDataResponse(soap, tag, id, (const struct atxml__RetrieveTpsDataResponse *)ptr, "atxml:RetrieveTpsDataResponse");
	case SOAP_TYPE_atxml__RegisterInterUsed:
		return soap_out_atxml__RegisterInterUsed(soap, tag, id, (const struct atxml__RegisterInterUsed *)ptr, "atxml:RegisterInterUsed");
	case SOAP_TYPE_atxml__RegisterInterUsedResponse:
		return soap_out_atxml__RegisterInterUsedResponse(soap, tag, id, (const struct atxml__RegisterInterUsedResponse *)ptr, "atxml:RegisterInterUsedResponse");
	case SOAP_TYPE_atxml__Close:
		return soap_out_atxml__Close(soap, tag, id, (const struct atxml__Close *)ptr, "atxml:Close");
	case SOAP_TYPE_atxml__CloseResponse:
		return soap_out_atxml__CloseResponse(soap, tag, id, (const struct atxml__CloseResponse *)ptr, "atxml:CloseResponse");
	case SOAP_TYPE_atxml__Initialize:
		return soap_out_atxml__Initialize(soap, tag, id, (const struct atxml__Initialize *)ptr, "atxml:Initialize");
	case SOAP_TYPE_atxml__InitializeResponse:
		return soap_out_atxml__InitializeResponse(soap, tag, id, (const struct atxml__InitializeResponse *)ptr, "atxml:InitializeResponse");
	case SOAP_TYPE_PointerToSOAP_ENV__Reason:
		return soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, (struct SOAP_ENV__Reason *const*)ptr, "SOAP-ENV:Reason");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_xsd__string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_SOAP_ENV__Reason:
		soap_serialize_SOAP_ENV__Reason(soap, (const struct SOAP_ENV__Reason *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueDriverFunctionCall:
		soap_serialize_atxml__IssueDriverFunctionCall(soap, (const struct atxml__IssueDriverFunctionCall *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueDriverFunctionCallResponse:
		soap_serialize_atxml__IssueDriverFunctionCallResponse(soap, (const struct atxml__IssueDriverFunctionCallResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueNativeCmds:
		soap_serialize_atxml__IssueNativeCmds(soap, (const struct atxml__IssueNativeCmds *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueNativeCmdsResponse:
		soap_serialize_atxml__IssueNativeCmdsResponse(soap, (const struct atxml__IssueNativeCmdsResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueIst:
		soap_serialize_atxml__IssueIst(soap, (const struct atxml__IssueIst *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueIstResponse:
		soap_serialize_atxml__IssueIstResponse(soap, (const struct atxml__IssueIstResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueTestResultsFile:
		soap_serialize_atxml__IssueTestResultsFile(soap, (const struct atxml__IssueTestResultsFile *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueTestResultsFileResponse:
		soap_serialize_atxml__IssueTestResultsFileResponse(soap, (const struct atxml__IssueTestResultsFileResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueTestResults:
		soap_serialize_atxml__IssueTestResults(soap, (const struct atxml__IssueTestResults *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueTestResultsResponse:
		soap_serialize_atxml__IssueTestResultsResponse(soap, (const struct atxml__IssueTestResultsResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__InvokeRemoveAllSequence:
		soap_serialize_atxml__InvokeRemoveAllSequence(soap, (const struct atxml__InvokeRemoveAllSequence *)ptr);
		break;
	case SOAP_TYPE_atxml__InvokeRemoveAllSequenceResponse:
		soap_serialize_atxml__InvokeRemoveAllSequenceResponse(soap, (const struct atxml__InvokeRemoveAllSequenceResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__QueryInterStatus:
		soap_serialize_atxml__QueryInterStatus(soap, (const struct atxml__QueryInterStatus *)ptr);
		break;
	case SOAP_TYPE_atxml__QueryInterStatusResponse:
		soap_serialize_atxml__QueryInterStatusResponse(soap, (const struct atxml__QueryInterStatusResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueSignal:
		soap_serialize_atxml__IssueSignal(soap, (const struct atxml__IssueSignal *)ptr);
		break;
	case SOAP_TYPE_atxml__IssueSignalResponse:
		soap_serialize_atxml__IssueSignalResponse(soap, (const struct atxml__IssueSignalResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__SubmitUutId:
		soap_serialize_atxml__SubmitUutId(soap, (const struct atxml__SubmitUutId *)ptr);
		break;
	case SOAP_TYPE_atxml__SubmitUutIdResponse:
		soap_serialize_atxml__SubmitUutIdResponse(soap, (const struct atxml__SubmitUutIdResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__RegisterTmaSelect:
		soap_serialize_atxml__RegisterTmaSelect(soap, (const struct atxml__RegisterTmaSelect *)ptr);
		break;
	case SOAP_TYPE_atxml__RegisterTmaSelectResponse:
		soap_serialize_atxml__RegisterTmaSelectResponse(soap, (const struct atxml__RegisterTmaSelectResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__RegisterInstStatus:
		soap_serialize_atxml__RegisterInstStatus(soap, (const struct atxml__RegisterInstStatus *)ptr);
		break;
	case SOAP_TYPE_atxml__RegisterInstStatusResponse:
		soap_serialize_atxml__RegisterInstStatusResponse(soap, (const struct atxml__RegisterInstStatusResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__TestStationStatus:
		soap_serialize_atxml__TestStationStatus(soap, (const struct atxml__TestStationStatus *)ptr);
		break;
	case SOAP_TYPE_atxml__TestStationStatusResponse:
		soap_serialize_atxml__TestStationStatusResponse(soap, (const struct atxml__TestStationStatusResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__RegisterRemoveSequence:
		soap_serialize_atxml__RegisterRemoveSequence(soap, (const struct atxml__RegisterRemoveSequence *)ptr);
		break;
	case SOAP_TYPE_atxml__RegisterRemoveSequenceResponse:
		soap_serialize_atxml__RegisterRemoveSequenceResponse(soap, (const struct atxml__RegisterRemoveSequenceResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__ValidateRequirements:
		soap_serialize_atxml__ValidateRequirements(soap, (const struct atxml__ValidateRequirements *)ptr);
		break;
	case SOAP_TYPE_atxml__ValidateRequirementsResponse:
		soap_serialize_atxml__ValidateRequirementsResponse(soap, (const struct atxml__ValidateRequirementsResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__RegisterTSF:
		soap_serialize_atxml__RegisterTSF(soap, (const struct atxml__RegisterTSF *)ptr);
		break;
	case SOAP_TYPE_atxml__RegisterTSFResponse:
		soap_serialize_atxml__RegisterTSFResponse(soap, (const struct atxml__RegisterTSFResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__RetrieveTpsData:
		soap_serialize_atxml__RetrieveTpsData(soap, (const struct atxml__RetrieveTpsData *)ptr);
		break;
	case SOAP_TYPE_atxml__RetrieveTpsDataResponse:
		soap_serialize_atxml__RetrieveTpsDataResponse(soap, (const struct atxml__RetrieveTpsDataResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__RegisterInterUsed:
		soap_serialize_atxml__RegisterInterUsed(soap, (const struct atxml__RegisterInterUsed *)ptr);
		break;
	case SOAP_TYPE_atxml__RegisterInterUsedResponse:
		soap_serialize_atxml__RegisterInterUsedResponse(soap, (const struct atxml__RegisterInterUsedResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__Close:
		soap_serialize_atxml__Close(soap, (const struct atxml__Close *)ptr);
		break;
	case SOAP_TYPE_atxml__CloseResponse:
		soap_serialize_atxml__CloseResponse(soap, (const struct atxml__CloseResponse *)ptr);
		break;
	case SOAP_TYPE_atxml__Initialize:
		soap_serialize_atxml__Initialize(soap, (const struct atxml__Initialize *)ptr);
		break;
	case SOAP_TYPE_atxml__InitializeResponse:
		soap_serialize_atxml__InitializeResponse(soap, (const struct atxml__InitializeResponse *)ptr);
		break;
	case SOAP_TYPE_PointerToSOAP_ENV__Reason:
		soap_serialize_PointerToSOAP_ENV__Reason(soap, (struct SOAP_ENV__Reason *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_xsd__string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueDriverFunctionCall(struct soap *soap, const struct atxml__IssueDriverFunctionCall *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->DriverFunction);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueDriverFunctionCall(struct soap *soap, struct atxml__IssueDriverFunctionCall *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->DriverFunction);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueDriverFunctionCall(struct soap *soap, const struct atxml__IssueDriverFunctionCall *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueDriverFunctionCall);
	if (soap_out_atxml__IssueDriverFunctionCall(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueDriverFunctionCall(struct soap *soap, const char *tag, int id, const struct atxml__IssueDriverFunctionCall *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueDriverFunctionCall), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "DriverFunction", -1, &a->DriverFunction, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueDriverFunctionCall * SOAP_FMAC4 soap_get_atxml__IssueDriverFunctionCall(struct soap *soap, struct atxml__IssueDriverFunctionCall *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueDriverFunctionCall(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueDriverFunctionCall * SOAP_FMAC4 soap_in_atxml__IssueDriverFunctionCall(struct soap *soap, const char *tag, struct atxml__IssueDriverFunctionCall *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_DriverFunction = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueDriverFunctionCall *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueDriverFunctionCall, sizeof(struct atxml__IssueDriverFunctionCall), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueDriverFunctionCall(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_DriverFunction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "DriverFunction", &a->DriverFunction, "xsd:string"))
				{	soap_flag_DriverFunction--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueDriverFunctionCall *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueDriverFunctionCall, 0, sizeof(struct atxml__IssueDriverFunctionCall), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueDriverFunctionCallResponse(struct soap *soap, const struct atxml__IssueDriverFunctionCallResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Response);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueDriverFunctionCallResponse(struct soap *soap, struct atxml__IssueDriverFunctionCallResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Response);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueDriverFunctionCallResponse(struct soap *soap, const struct atxml__IssueDriverFunctionCallResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueDriverFunctionCallResponse);
	if (soap_out_atxml__IssueDriverFunctionCallResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueDriverFunctionCallResponse(struct soap *soap, const char *tag, int id, const struct atxml__IssueDriverFunctionCallResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueDriverFunctionCallResponse), type);
	if (a->Response)
		soap_element_result(soap, "Response");
	soap_out_xsd__string(soap, "Response", -1, &a->Response, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueDriverFunctionCallResponse * SOAP_FMAC4 soap_get_atxml__IssueDriverFunctionCallResponse(struct soap *soap, struct atxml__IssueDriverFunctionCallResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueDriverFunctionCallResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueDriverFunctionCallResponse * SOAP_FMAC4 soap_in_atxml__IssueDriverFunctionCallResponse(struct soap *soap, const char *tag, struct atxml__IssueDriverFunctionCallResponse *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueDriverFunctionCallResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueDriverFunctionCallResponse, sizeof(struct atxml__IssueDriverFunctionCallResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueDriverFunctionCallResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Response", &a->Response, "xsd:string"))
				{	soap_flag_Response--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueDriverFunctionCallResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueDriverFunctionCallResponse, 0, sizeof(struct atxml__IssueDriverFunctionCallResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueNativeCmds(struct soap *soap, const struct atxml__IssueNativeCmds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->InstrumentCmds);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueNativeCmds(struct soap *soap, struct atxml__IssueNativeCmds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->InstrumentCmds);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueNativeCmds(struct soap *soap, const struct atxml__IssueNativeCmds *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueNativeCmds);
	if (soap_out_atxml__IssueNativeCmds(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueNativeCmds(struct soap *soap, const char *tag, int id, const struct atxml__IssueNativeCmds *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueNativeCmds), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "InstrumentCmds", -1, &a->InstrumentCmds, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueNativeCmds * SOAP_FMAC4 soap_get_atxml__IssueNativeCmds(struct soap *soap, struct atxml__IssueNativeCmds *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueNativeCmds(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueNativeCmds * SOAP_FMAC4 soap_in_atxml__IssueNativeCmds(struct soap *soap, const char *tag, struct atxml__IssueNativeCmds *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_InstrumentCmds = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueNativeCmds *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueNativeCmds, sizeof(struct atxml__IssueNativeCmds), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueNativeCmds(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_InstrumentCmds && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "InstrumentCmds", &a->InstrumentCmds, "xsd:string"))
				{	soap_flag_InstrumentCmds--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueNativeCmds *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueNativeCmds, 0, sizeof(struct atxml__IssueNativeCmds), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueNativeCmdsResponse(struct soap *soap, const struct atxml__IssueNativeCmdsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Response);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueNativeCmdsResponse(struct soap *soap, struct atxml__IssueNativeCmdsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Response);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueNativeCmdsResponse(struct soap *soap, const struct atxml__IssueNativeCmdsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueNativeCmdsResponse);
	if (soap_out_atxml__IssueNativeCmdsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueNativeCmdsResponse(struct soap *soap, const char *tag, int id, const struct atxml__IssueNativeCmdsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueNativeCmdsResponse), type);
	if (a->Response)
		soap_element_result(soap, "Response");
	soap_out_xsd__string(soap, "Response", -1, &a->Response, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueNativeCmdsResponse * SOAP_FMAC4 soap_get_atxml__IssueNativeCmdsResponse(struct soap *soap, struct atxml__IssueNativeCmdsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueNativeCmdsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueNativeCmdsResponse * SOAP_FMAC4 soap_in_atxml__IssueNativeCmdsResponse(struct soap *soap, const char *tag, struct atxml__IssueNativeCmdsResponse *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueNativeCmdsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueNativeCmdsResponse, sizeof(struct atxml__IssueNativeCmdsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueNativeCmdsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Response", &a->Response, "xsd:string"))
				{	soap_flag_Response--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueNativeCmdsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueNativeCmdsResponse, 0, sizeof(struct atxml__IssueNativeCmdsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueIst(struct soap *soap, const struct atxml__IssueIst *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->InstSelfTest);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueIst(struct soap *soap, struct atxml__IssueIst *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->InstSelfTest);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueIst(struct soap *soap, const struct atxml__IssueIst *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueIst);
	if (soap_out_atxml__IssueIst(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueIst(struct soap *soap, const char *tag, int id, const struct atxml__IssueIst *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueIst), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "InstSelfTest", -1, &a->InstSelfTest, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueIst * SOAP_FMAC4 soap_get_atxml__IssueIst(struct soap *soap, struct atxml__IssueIst *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueIst(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueIst * SOAP_FMAC4 soap_in_atxml__IssueIst(struct soap *soap, const char *tag, struct atxml__IssueIst *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_InstSelfTest = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueIst *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueIst, sizeof(struct atxml__IssueIst), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueIst(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_InstSelfTest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "InstSelfTest", &a->InstSelfTest, "xsd:string"))
				{	soap_flag_InstSelfTest--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueIst *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueIst, 0, sizeof(struct atxml__IssueIst), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueIstResponse(struct soap *soap, const struct atxml__IssueIstResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Response);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueIstResponse(struct soap *soap, struct atxml__IssueIstResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Response);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueIstResponse(struct soap *soap, const struct atxml__IssueIstResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueIstResponse);
	if (soap_out_atxml__IssueIstResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueIstResponse(struct soap *soap, const char *tag, int id, const struct atxml__IssueIstResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueIstResponse), type);
	if (a->Response)
		soap_element_result(soap, "Response");
	soap_out_xsd__string(soap, "Response", -1, &a->Response, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueIstResponse * SOAP_FMAC4 soap_get_atxml__IssueIstResponse(struct soap *soap, struct atxml__IssueIstResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueIstResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueIstResponse * SOAP_FMAC4 soap_in_atxml__IssueIstResponse(struct soap *soap, const char *tag, struct atxml__IssueIstResponse *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueIstResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueIstResponse, sizeof(struct atxml__IssueIstResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueIstResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Response", &a->Response, "xsd:string"))
				{	soap_flag_Response--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueIstResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueIstResponse, 0, sizeof(struct atxml__IssueIstResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueTestResultsFile(struct soap *soap, const struct atxml__IssueTestResultsFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->TestResultsFile);
	soap_embedded(soap, &a->TPS_Status, SOAP_TYPE_int);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueTestResultsFile(struct soap *soap, struct atxml__IssueTestResultsFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->TestResultsFile);
	soap_default_int(soap, &a->TPS_Status);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueTestResultsFile(struct soap *soap, const struct atxml__IssueTestResultsFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueTestResultsFile);
	if (soap_out_atxml__IssueTestResultsFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueTestResultsFile(struct soap *soap, const char *tag, int id, const struct atxml__IssueTestResultsFile *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueTestResultsFile), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "TestResultsFile", -1, &a->TestResultsFile, "");
	soap_out_int(soap, "TPS-Status", -1, &a->TPS_Status, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueTestResultsFile * SOAP_FMAC4 soap_get_atxml__IssueTestResultsFile(struct soap *soap, struct atxml__IssueTestResultsFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueTestResultsFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueTestResultsFile * SOAP_FMAC4 soap_in_atxml__IssueTestResultsFile(struct soap *soap, const char *tag, struct atxml__IssueTestResultsFile *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_TestResultsFile = 1, soap_flag_TPS_Status = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueTestResultsFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueTestResultsFile, sizeof(struct atxml__IssueTestResultsFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueTestResultsFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_TestResultsFile && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "TestResultsFile", &a->TestResultsFile, "xsd:string"))
				{	soap_flag_TestResultsFile--;
					continue;
				}
			if (soap_flag_TPS_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TPS-Status", &a->TPS_Status, "xsd:int"))
				{	soap_flag_TPS_Status--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_TPS_Status > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueTestResultsFile *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueTestResultsFile, 0, sizeof(struct atxml__IssueTestResultsFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueTestResultsFileResponse(struct soap *soap, const struct atxml__IssueTestResultsFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Response);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueTestResultsFileResponse(struct soap *soap, struct atxml__IssueTestResultsFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Response);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueTestResultsFileResponse(struct soap *soap, const struct atxml__IssueTestResultsFileResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueTestResultsFileResponse);
	if (soap_out_atxml__IssueTestResultsFileResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueTestResultsFileResponse(struct soap *soap, const char *tag, int id, const struct atxml__IssueTestResultsFileResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueTestResultsFileResponse), type);
	if (a->Response)
		soap_element_result(soap, "Response");
	soap_out_xsd__string(soap, "Response", -1, &a->Response, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueTestResultsFileResponse * SOAP_FMAC4 soap_get_atxml__IssueTestResultsFileResponse(struct soap *soap, struct atxml__IssueTestResultsFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueTestResultsFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueTestResultsFileResponse * SOAP_FMAC4 soap_in_atxml__IssueTestResultsFileResponse(struct soap *soap, const char *tag, struct atxml__IssueTestResultsFileResponse *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueTestResultsFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueTestResultsFileResponse, sizeof(struct atxml__IssueTestResultsFileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueTestResultsFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Response", &a->Response, "xsd:string"))
				{	soap_flag_Response--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueTestResultsFileResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueTestResultsFileResponse, 0, sizeof(struct atxml__IssueTestResultsFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueTestResults(struct soap *soap, const struct atxml__IssueTestResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->TestResults);
	soap_embedded(soap, &a->TPS_Status, SOAP_TYPE_int);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueTestResults(struct soap *soap, struct atxml__IssueTestResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->TestResults);
	soap_default_int(soap, &a->TPS_Status);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueTestResults(struct soap *soap, const struct atxml__IssueTestResults *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueTestResults);
	if (soap_out_atxml__IssueTestResults(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueTestResults(struct soap *soap, const char *tag, int id, const struct atxml__IssueTestResults *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueTestResults), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "TestResults", -1, &a->TestResults, "");
	soap_out_int(soap, "TPS-Status", -1, &a->TPS_Status, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueTestResults * SOAP_FMAC4 soap_get_atxml__IssueTestResults(struct soap *soap, struct atxml__IssueTestResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueTestResults(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueTestResults * SOAP_FMAC4 soap_in_atxml__IssueTestResults(struct soap *soap, const char *tag, struct atxml__IssueTestResults *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_TestResults = 1, soap_flag_TPS_Status = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueTestResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueTestResults, sizeof(struct atxml__IssueTestResults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueTestResults(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_TestResults && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "TestResults", &a->TestResults, "xsd:string"))
				{	soap_flag_TestResults--;
					continue;
				}
			if (soap_flag_TPS_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TPS-Status", &a->TPS_Status, "xsd:int"))
				{	soap_flag_TPS_Status--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_TPS_Status > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueTestResults *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueTestResults, 0, sizeof(struct atxml__IssueTestResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueTestResultsResponse(struct soap *soap, const struct atxml__IssueTestResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Response);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueTestResultsResponse(struct soap *soap, struct atxml__IssueTestResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Response);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueTestResultsResponse(struct soap *soap, const struct atxml__IssueTestResultsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueTestResultsResponse);
	if (soap_out_atxml__IssueTestResultsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueTestResultsResponse(struct soap *soap, const char *tag, int id, const struct atxml__IssueTestResultsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueTestResultsResponse), type);
	if (a->Response)
		soap_element_result(soap, "Response");
	soap_out_xsd__string(soap, "Response", -1, &a->Response, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueTestResultsResponse * SOAP_FMAC4 soap_get_atxml__IssueTestResultsResponse(struct soap *soap, struct atxml__IssueTestResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueTestResultsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueTestResultsResponse * SOAP_FMAC4 soap_in_atxml__IssueTestResultsResponse(struct soap *soap, const char *tag, struct atxml__IssueTestResultsResponse *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueTestResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueTestResultsResponse, sizeof(struct atxml__IssueTestResultsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueTestResultsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Response", &a->Response, "xsd:string"))
				{	soap_flag_Response--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueTestResultsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueTestResultsResponse, 0, sizeof(struct atxml__IssueTestResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__InvokeRemoveAllSequence(struct soap *soap, const struct atxml__InvokeRemoveAllSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__InvokeRemoveAllSequence(struct soap *soap, struct atxml__InvokeRemoveAllSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__InvokeRemoveAllSequence(struct soap *soap, const struct atxml__InvokeRemoveAllSequence *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__InvokeRemoveAllSequence);
	if (soap_out_atxml__InvokeRemoveAllSequence(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__InvokeRemoveAllSequence(struct soap *soap, const char *tag, int id, const struct atxml__InvokeRemoveAllSequence *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__InvokeRemoveAllSequence), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__InvokeRemoveAllSequence * SOAP_FMAC4 soap_get_atxml__InvokeRemoveAllSequence(struct soap *soap, struct atxml__InvokeRemoveAllSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__InvokeRemoveAllSequence(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__InvokeRemoveAllSequence * SOAP_FMAC4 soap_in_atxml__InvokeRemoveAllSequence(struct soap *soap, const char *tag, struct atxml__InvokeRemoveAllSequence *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__InvokeRemoveAllSequence *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__InvokeRemoveAllSequence, sizeof(struct atxml__InvokeRemoveAllSequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__InvokeRemoveAllSequence(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__InvokeRemoveAllSequence *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__InvokeRemoveAllSequence, 0, sizeof(struct atxml__InvokeRemoveAllSequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__InvokeRemoveAllSequenceResponse(struct soap *soap, const struct atxml__InvokeRemoveAllSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Response);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__InvokeRemoveAllSequenceResponse(struct soap *soap, struct atxml__InvokeRemoveAllSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Response);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__InvokeRemoveAllSequenceResponse(struct soap *soap, const struct atxml__InvokeRemoveAllSequenceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__InvokeRemoveAllSequenceResponse);
	if (soap_out_atxml__InvokeRemoveAllSequenceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__InvokeRemoveAllSequenceResponse(struct soap *soap, const char *tag, int id, const struct atxml__InvokeRemoveAllSequenceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__InvokeRemoveAllSequenceResponse), type);
	if (a->Response)
		soap_element_result(soap, "Response");
	soap_out_xsd__string(soap, "Response", -1, &a->Response, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__InvokeRemoveAllSequenceResponse * SOAP_FMAC4 soap_get_atxml__InvokeRemoveAllSequenceResponse(struct soap *soap, struct atxml__InvokeRemoveAllSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__InvokeRemoveAllSequenceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__InvokeRemoveAllSequenceResponse * SOAP_FMAC4 soap_in_atxml__InvokeRemoveAllSequenceResponse(struct soap *soap, const char *tag, struct atxml__InvokeRemoveAllSequenceResponse *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__InvokeRemoveAllSequenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__InvokeRemoveAllSequenceResponse, sizeof(struct atxml__InvokeRemoveAllSequenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__InvokeRemoveAllSequenceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Response", &a->Response, "xsd:string"))
				{	soap_flag_Response--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__InvokeRemoveAllSequenceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__InvokeRemoveAllSequenceResponse, 0, sizeof(struct atxml__InvokeRemoveAllSequenceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__InvokeApplyAllSequence(struct soap *soap, const struct atxml__InvokeApplyAllSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__InvokeApplyAllSequence(struct soap *soap, struct atxml__InvokeApplyAllSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__InvokeApplyAllSequence(struct soap *soap, const struct atxml__InvokeApplyAllSequence *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__InvokeApplyAllSequence);
	if (soap_out_atxml__InvokeApplyAllSequence(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__InvokeApplyAllSequence(struct soap *soap, const char *tag, int id, const struct atxml__InvokeApplyAllSequence *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__InvokeApplyAllSequence), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__InvokeApplyAllSequence * SOAP_FMAC4 soap_get_atxml__InvokeApplyAllSequence(struct soap *soap, struct atxml__InvokeApplyAllSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__InvokeApplyAllSequence(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__InvokeApplyAllSequence * SOAP_FMAC4 soap_in_atxml__InvokeApplyAllSequence(struct soap *soap, const char *tag, struct atxml__InvokeApplyAllSequence *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__InvokeApplyAllSequence *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__InvokeApplyAllSequence, sizeof(struct atxml__InvokeApplyAllSequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__InvokeApplyAllSequence(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__InvokeApplyAllSequence *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__InvokeApplyAllSequence, 0, sizeof(struct atxml__InvokeApplyAllSequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__InvokeApplyAllSequenceResponse(struct soap *soap, const struct atxml__InvokeApplyAllSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Response);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__InvokeApplyAllSequenceResponse(struct soap *soap, struct atxml__InvokeApplyAllSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Response);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__InvokeApplyAllSequenceResponse(struct soap *soap, const struct atxml__InvokeApplyAllSequenceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__InvokeApplyAllSequenceResponse);
	if (soap_out_atxml__InvokeApplyAllSequenceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__InvokeApplyAllSequenceResponse(struct soap *soap, const char *tag, int id, const struct atxml__InvokeApplyAllSequenceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__InvokeApplyAllSequenceResponse), type);
	if (a->Response)
		soap_element_result(soap, "Response");
	soap_out_xsd__string(soap, "Response", -1, &a->Response, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__InvokeApplyAllSequenceResponse * SOAP_FMAC4 soap_get_atxml__InvokeApplyAllSequenceResponse(struct soap *soap, struct atxml__InvokeApplyAllSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__InvokeApplyAllSequenceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__InvokeApplyAllSequenceResponse * SOAP_FMAC4 soap_in_atxml__InvokeApplyAllSequenceResponse(struct soap *soap, const char *tag, struct atxml__InvokeApplyAllSequenceResponse *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__InvokeApplyAllSequenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__InvokeApplyAllSequenceResponse, sizeof(struct atxml__InvokeApplyAllSequenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__InvokeApplyAllSequenceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Response", &a->Response, "xsd:string"))
				{	soap_flag_Response--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__InvokeApplyAllSequenceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__InvokeApplyAllSequenceResponse, 0, sizeof(struct atxml__InvokeApplyAllSequenceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__QueryInterStatus(struct soap *soap, const struct atxml__QueryInterStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__QueryInterStatus(struct soap *soap, struct atxml__QueryInterStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__QueryInterStatus(struct soap *soap, const struct atxml__QueryInterStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__QueryInterStatus);
	if (soap_out_atxml__QueryInterStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__QueryInterStatus(struct soap *soap, const char *tag, int id, const struct atxml__QueryInterStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__QueryInterStatus), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__QueryInterStatus * SOAP_FMAC4 soap_get_atxml__QueryInterStatus(struct soap *soap, struct atxml__QueryInterStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__QueryInterStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__QueryInterStatus * SOAP_FMAC4 soap_in_atxml__QueryInterStatus(struct soap *soap, const char *tag, struct atxml__QueryInterStatus *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__QueryInterStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__QueryInterStatus, sizeof(struct atxml__QueryInterStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__QueryInterStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__QueryInterStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__QueryInterStatus, 0, sizeof(struct atxml__QueryInterStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__QueryInterStatusResponse(struct soap *soap, const struct atxml__QueryInterStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->InterStatus);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__QueryInterStatusResponse(struct soap *soap, struct atxml__QueryInterStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->InterStatus);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__QueryInterStatusResponse(struct soap *soap, const struct atxml__QueryInterStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__QueryInterStatusResponse);
	if (soap_out_atxml__QueryInterStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__QueryInterStatusResponse(struct soap *soap, const char *tag, int id, const struct atxml__QueryInterStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__QueryInterStatusResponse), type);
	if (a->InterStatus)
		soap_element_result(soap, "InterStatus");
	soap_out_xsd__string(soap, "InterStatus", -1, &a->InterStatus, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__QueryInterStatusResponse * SOAP_FMAC4 soap_get_atxml__QueryInterStatusResponse(struct soap *soap, struct atxml__QueryInterStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__QueryInterStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__QueryInterStatusResponse * SOAP_FMAC4 soap_in_atxml__QueryInterStatusResponse(struct soap *soap, const char *tag, struct atxml__QueryInterStatusResponse *a, const char *type)
{
	short soap_flag_InterStatus = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__QueryInterStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__QueryInterStatusResponse, sizeof(struct atxml__QueryInterStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__QueryInterStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterStatus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "InterStatus", &a->InterStatus, "xsd:string"))
				{	soap_flag_InterStatus--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__QueryInterStatusResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__QueryInterStatusResponse, 0, sizeof(struct atxml__QueryInterStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueSignal(struct soap *soap, const struct atxml__IssueSignal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->SignalDescription);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueSignal(struct soap *soap, struct atxml__IssueSignal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->SignalDescription);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueSignal(struct soap *soap, const struct atxml__IssueSignal *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueSignal);
	if (soap_out_atxml__IssueSignal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueSignal(struct soap *soap, const char *tag, int id, const struct atxml__IssueSignal *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueSignal), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "SignalDescription", -1, &a->SignalDescription, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueSignal * SOAP_FMAC4 soap_get_atxml__IssueSignal(struct soap *soap, struct atxml__IssueSignal *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueSignal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueSignal * SOAP_FMAC4 soap_in_atxml__IssueSignal(struct soap *soap, const char *tag, struct atxml__IssueSignal *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_SignalDescription = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueSignal *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueSignal, sizeof(struct atxml__IssueSignal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueSignal(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_SignalDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "SignalDescription", &a->SignalDescription, "xsd:string"))
				{	soap_flag_SignalDescription--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueSignal *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueSignal, 0, sizeof(struct atxml__IssueSignal), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__IssueSignalResponse(struct soap *soap, const struct atxml__IssueSignalResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Response);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__IssueSignalResponse(struct soap *soap, struct atxml__IssueSignalResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Response);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__IssueSignalResponse(struct soap *soap, const struct atxml__IssueSignalResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__IssueSignalResponse);
	if (soap_out_atxml__IssueSignalResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__IssueSignalResponse(struct soap *soap, const char *tag, int id, const struct atxml__IssueSignalResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__IssueSignalResponse), type);
	if (a->Response)
		soap_element_result(soap, "Response");
	soap_out_xsd__string(soap, "Response", -1, &a->Response, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__IssueSignalResponse * SOAP_FMAC4 soap_get_atxml__IssueSignalResponse(struct soap *soap, struct atxml__IssueSignalResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__IssueSignalResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__IssueSignalResponse * SOAP_FMAC4 soap_in_atxml__IssueSignalResponse(struct soap *soap, const char *tag, struct atxml__IssueSignalResponse *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__IssueSignalResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__IssueSignalResponse, sizeof(struct atxml__IssueSignalResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__IssueSignalResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Response", &a->Response, "xsd:string"))
				{	soap_flag_Response--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__IssueSignalResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__IssueSignalResponse, 0, sizeof(struct atxml__IssueSignalResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__SubmitUutId(struct soap *soap, const struct atxml__SubmitUutId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->UUT_Partnumber);
	soap_serialize_string(soap, &a->UUT_Serialnumber);
	soap_embedded(soap, &a->TmaBufferSize, SOAP_TYPE_int);
	soap_embedded(soap, &a->RaBufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__SubmitUutId(struct soap *soap, struct atxml__SubmitUutId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_string(soap, &a->UUT_Partnumber);
	soap_default_string(soap, &a->UUT_Serialnumber);
	soap_default_int(soap, &a->TmaBufferSize);
	soap_default_int(soap, &a->RaBufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__SubmitUutId(struct soap *soap, const struct atxml__SubmitUutId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__SubmitUutId);
	if (soap_out_atxml__SubmitUutId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__SubmitUutId(struct soap *soap, const char *tag, int id, const struct atxml__SubmitUutId *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__SubmitUutId), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_string(soap, "UUT-Partnumber", -1, &a->UUT_Partnumber, "");
	soap_out_string(soap, "UUT-Serialnumber", -1, &a->UUT_Serialnumber, "");
	soap_out_int(soap, "TmaBufferSize", -1, &a->TmaBufferSize, "");
	soap_out_int(soap, "RaBufferSize", -1, &a->RaBufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__SubmitUutId * SOAP_FMAC4 soap_get_atxml__SubmitUutId(struct soap *soap, struct atxml__SubmitUutId *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__SubmitUutId(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__SubmitUutId * SOAP_FMAC4 soap_in_atxml__SubmitUutId(struct soap *soap, const char *tag, struct atxml__SubmitUutId *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_UUT_Partnumber = 1, soap_flag_UUT_Serialnumber = 1, soap_flag_TmaBufferSize = 1, soap_flag_RaBufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__SubmitUutId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__SubmitUutId, sizeof(struct atxml__SubmitUutId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__SubmitUutId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_UUT_Partnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "UUT-Partnumber", &a->UUT_Partnumber, "xsd:string"))
				{	soap_flag_UUT_Partnumber--;
					continue;
				}
			if (soap_flag_UUT_Serialnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "UUT-Serialnumber", &a->UUT_Serialnumber, "xsd:string"))
				{	soap_flag_UUT_Serialnumber--;
					continue;
				}
			if (soap_flag_TmaBufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TmaBufferSize", &a->TmaBufferSize, "xsd:int"))
				{	soap_flag_TmaBufferSize--;
					continue;
				}
			if (soap_flag_RaBufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "RaBufferSize", &a->RaBufferSize, "xsd:int"))
				{	soap_flag_RaBufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_TmaBufferSize > 0 || soap_flag_RaBufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__SubmitUutId *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__SubmitUutId, 0, sizeof(struct atxml__SubmitUutId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__SubmitUutIdResponse(struct soap *soap, const struct atxml__SubmitUutIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Action, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->cTmaList);
	soap_embedded(soap, &a->TmaBufferSize, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->RecommendedActions);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__SubmitUutIdResponse(struct soap *soap, struct atxml__SubmitUutIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Action);
	soap_default_xsd__string(soap, &a->cTmaList);
	soap_default_int(soap, &a->TmaBufferSize);
	soap_default_xsd__string(soap, &a->RecommendedActions);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__SubmitUutIdResponse(struct soap *soap, const struct atxml__SubmitUutIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__SubmitUutIdResponse);
	if (soap_out_atxml__SubmitUutIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__SubmitUutIdResponse(struct soap *soap, const char *tag, int id, const struct atxml__SubmitUutIdResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__SubmitUutIdResponse), type);
	soap_element_result(soap, "Action");
	soap_out_int(soap, "Action", -1, &a->Action, "");
	soap_out_xsd__string(soap, "cTmaList", -1, &a->cTmaList, "");
	soap_out_int(soap, "TmaBufferSize", -1, &a->TmaBufferSize, "");
	soap_out_xsd__string(soap, "RecommendedActions", -1, &a->RecommendedActions, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__SubmitUutIdResponse * SOAP_FMAC4 soap_get_atxml__SubmitUutIdResponse(struct soap *soap, struct atxml__SubmitUutIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__SubmitUutIdResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__SubmitUutIdResponse * SOAP_FMAC4 soap_in_atxml__SubmitUutIdResponse(struct soap *soap, const char *tag, struct atxml__SubmitUutIdResponse *a, const char *type)
{
	short soap_flag_Action = 1, soap_flag_cTmaList = 1, soap_flag_TmaBufferSize = 1, soap_flag_RecommendedActions = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__SubmitUutIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__SubmitUutIdResponse, sizeof(struct atxml__SubmitUutIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__SubmitUutIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Action", &a->Action, "xsd:int"))
				{	soap_flag_Action--;
					continue;
				}
			if (soap_flag_cTmaList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "cTmaList", &a->cTmaList, "xsd:string"))
				{	soap_flag_cTmaList--;
					continue;
				}
			if (soap_flag_TmaBufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TmaBufferSize", &a->TmaBufferSize, "xsd:int"))
				{	soap_flag_TmaBufferSize--;
					continue;
				}
			if (soap_flag_RecommendedActions && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "RecommendedActions", &a->RecommendedActions, "xsd:string"))
				{	soap_flag_RecommendedActions--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Action > 0 || soap_flag_TmaBufferSize > 0 || soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__SubmitUutIdResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__SubmitUutIdResponse, 0, sizeof(struct atxml__SubmitUutIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterTmaSelect(struct soap *soap, const struct atxml__RegisterTmaSelect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->TmaList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterTmaSelect(struct soap *soap, struct atxml__RegisterTmaSelect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->TmaList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterTmaSelect(struct soap *soap, const struct atxml__RegisterTmaSelect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterTmaSelect);
	if (soap_out_atxml__RegisterTmaSelect(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterTmaSelect(struct soap *soap, const char *tag, int id, const struct atxml__RegisterTmaSelect *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterTmaSelect), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "TmaList", -1, &a->TmaList, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterTmaSelect * SOAP_FMAC4 soap_get_atxml__RegisterTmaSelect(struct soap *soap, struct atxml__RegisterTmaSelect *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterTmaSelect(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterTmaSelect * SOAP_FMAC4 soap_in_atxml__RegisterTmaSelect(struct soap *soap, const char *tag, struct atxml__RegisterTmaSelect *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_TmaList = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterTmaSelect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterTmaSelect, sizeof(struct atxml__RegisterTmaSelect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterTmaSelect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_TmaList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "TmaList", &a->TmaList, "xsd:string"))
				{	soap_flag_TmaList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterTmaSelect *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterTmaSelect, 0, sizeof(struct atxml__RegisterTmaSelect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterTmaSelectResponse(struct soap *soap, const struct atxml__RegisterTmaSelectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterTmaSelectResponse(struct soap *soap, struct atxml__RegisterTmaSelectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterTmaSelectResponse(struct soap *soap, const struct atxml__RegisterTmaSelectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterTmaSelectResponse);
	if (soap_out_atxml__RegisterTmaSelectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterTmaSelectResponse(struct soap *soap, const char *tag, int id, const struct atxml__RegisterTmaSelectResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterTmaSelectResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerToint(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterTmaSelectResponse * SOAP_FMAC4 soap_get_atxml__RegisterTmaSelectResponse(struct soap *soap, struct atxml__RegisterTmaSelectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterTmaSelectResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterTmaSelectResponse * SOAP_FMAC4 soap_in_atxml__RegisterTmaSelectResponse(struct soap *soap, const char *tag, struct atxml__RegisterTmaSelectResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterTmaSelectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterTmaSelectResponse, sizeof(struct atxml__RegisterTmaSelectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterTmaSelectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterTmaSelectResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterTmaSelectResponse, 0, sizeof(struct atxml__RegisterTmaSelectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterInstStatus(struct soap *soap, const struct atxml__RegisterInstStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->InstStatus);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterInstStatus(struct soap *soap, struct atxml__RegisterInstStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->InstStatus);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterInstStatus(struct soap *soap, const struct atxml__RegisterInstStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterInstStatus);
	if (soap_out_atxml__RegisterInstStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterInstStatus(struct soap *soap, const char *tag, int id, const struct atxml__RegisterInstStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterInstStatus), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "InstStatus", -1, &a->InstStatus, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterInstStatus * SOAP_FMAC4 soap_get_atxml__RegisterInstStatus(struct soap *soap, struct atxml__RegisterInstStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterInstStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterInstStatus * SOAP_FMAC4 soap_in_atxml__RegisterInstStatus(struct soap *soap, const char *tag, struct atxml__RegisterInstStatus *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_InstStatus = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterInstStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterInstStatus, sizeof(struct atxml__RegisterInstStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterInstStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_InstStatus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "InstStatus", &a->InstStatus, "xsd:string"))
				{	soap_flag_InstStatus--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterInstStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterInstStatus, 0, sizeof(struct atxml__RegisterInstStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterInstStatusResponse(struct soap *soap, const struct atxml__RegisterInstStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Response);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterInstStatusResponse(struct soap *soap, struct atxml__RegisterInstStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Response);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterInstStatusResponse(struct soap *soap, const struct atxml__RegisterInstStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterInstStatusResponse);
	if (soap_out_atxml__RegisterInstStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterInstStatusResponse(struct soap *soap, const char *tag, int id, const struct atxml__RegisterInstStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterInstStatusResponse), type);
	if (a->Response)
		soap_element_result(soap, "Response");
	soap_out_xsd__string(soap, "Response", -1, &a->Response, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterInstStatusResponse * SOAP_FMAC4 soap_get_atxml__RegisterInstStatusResponse(struct soap *soap, struct atxml__RegisterInstStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterInstStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterInstStatusResponse * SOAP_FMAC4 soap_in_atxml__RegisterInstStatusResponse(struct soap *soap, const char *tag, struct atxml__RegisterInstStatusResponse *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterInstStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterInstStatusResponse, sizeof(struct atxml__RegisterInstStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterInstStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Response", &a->Response, "xsd:string"))
				{	soap_flag_Response--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterInstStatusResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterInstStatusResponse, 0, sizeof(struct atxml__RegisterInstStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__TestStationStatus(struct soap *soap, const struct atxml__TestStationStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__TestStationStatus(struct soap *soap, struct atxml__TestStationStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__TestStationStatus(struct soap *soap, const struct atxml__TestStationStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__TestStationStatus);
	if (soap_out_atxml__TestStationStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__TestStationStatus(struct soap *soap, const char *tag, int id, const struct atxml__TestStationStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__TestStationStatus), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__TestStationStatus * SOAP_FMAC4 soap_get_atxml__TestStationStatus(struct soap *soap, struct atxml__TestStationStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__TestStationStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__TestStationStatus * SOAP_FMAC4 soap_in_atxml__TestStationStatus(struct soap *soap, const char *tag, struct atxml__TestStationStatus *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__TestStationStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__TestStationStatus, sizeof(struct atxml__TestStationStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__TestStationStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__TestStationStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__TestStationStatus, 0, sizeof(struct atxml__TestStationStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__TestStationStatusResponse(struct soap *soap, const struct atxml__TestStationStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->TestStationStatus);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__TestStationStatusResponse(struct soap *soap, struct atxml__TestStationStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->TestStationStatus);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__TestStationStatusResponse(struct soap *soap, const struct atxml__TestStationStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__TestStationStatusResponse);
	if (soap_out_atxml__TestStationStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__TestStationStatusResponse(struct soap *soap, const char *tag, int id, const struct atxml__TestStationStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__TestStationStatusResponse), type);
	if (a->TestStationStatus)
		soap_element_result(soap, "TestStationStatus");
	soap_out_xsd__string(soap, "TestStationStatus", -1, &a->TestStationStatus, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__TestStationStatusResponse * SOAP_FMAC4 soap_get_atxml__TestStationStatusResponse(struct soap *soap, struct atxml__TestStationStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__TestStationStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__TestStationStatusResponse * SOAP_FMAC4 soap_in_atxml__TestStationStatusResponse(struct soap *soap, const char *tag, struct atxml__TestStationStatusResponse *a, const char *type)
{
	short soap_flag_TestStationStatus = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__TestStationStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__TestStationStatusResponse, sizeof(struct atxml__TestStationStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__TestStationStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TestStationStatus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "TestStationStatus", &a->TestStationStatus, "xsd:string"))
				{	soap_flag_TestStationStatus--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__TestStationStatusResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__TestStationStatusResponse, 0, sizeof(struct atxml__TestStationStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterRemoveSequence(struct soap *soap, const struct atxml__RegisterRemoveSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->RemoveSequence);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterRemoveSequence(struct soap *soap, struct atxml__RegisterRemoveSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->RemoveSequence);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterRemoveSequence(struct soap *soap, const struct atxml__RegisterRemoveSequence *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterRemoveSequence);
	if (soap_out_atxml__RegisterRemoveSequence(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterRemoveSequence(struct soap *soap, const char *tag, int id, const struct atxml__RegisterRemoveSequence *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterRemoveSequence), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "RemoveSequence", -1, &a->RemoveSequence, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterRemoveSequence * SOAP_FMAC4 soap_get_atxml__RegisterRemoveSequence(struct soap *soap, struct atxml__RegisterRemoveSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterRemoveSequence(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterRemoveSequence * SOAP_FMAC4 soap_in_atxml__RegisterRemoveSequence(struct soap *soap, const char *tag, struct atxml__RegisterRemoveSequence *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_RemoveSequence = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterRemoveSequence *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterRemoveSequence, sizeof(struct atxml__RegisterRemoveSequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterRemoveSequence(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_RemoveSequence && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "RemoveSequence", &a->RemoveSequence, "xsd:string"))
				{	soap_flag_RemoveSequence--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterRemoveSequence *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterRemoveSequence, 0, sizeof(struct atxml__RegisterRemoveSequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterRemoveSequenceResponse(struct soap *soap, const struct atxml__RegisterRemoveSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Response);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterRemoveSequenceResponse(struct soap *soap, struct atxml__RegisterRemoveSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Response);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterRemoveSequenceResponse(struct soap *soap, const struct atxml__RegisterRemoveSequenceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterRemoveSequenceResponse);
	if (soap_out_atxml__RegisterRemoveSequenceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterRemoveSequenceResponse(struct soap *soap, const char *tag, int id, const struct atxml__RegisterRemoveSequenceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterRemoveSequenceResponse), type);
	if (a->Response)
		soap_element_result(soap, "Response");
	soap_out_xsd__string(soap, "Response", -1, &a->Response, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterRemoveSequenceResponse * SOAP_FMAC4 soap_get_atxml__RegisterRemoveSequenceResponse(struct soap *soap, struct atxml__RegisterRemoveSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterRemoveSequenceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterRemoveSequenceResponse * SOAP_FMAC4 soap_in_atxml__RegisterRemoveSequenceResponse(struct soap *soap, const char *tag, struct atxml__RegisterRemoveSequenceResponse *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterRemoveSequenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterRemoveSequenceResponse, sizeof(struct atxml__RegisterRemoveSequenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterRemoveSequenceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Response", &a->Response, "xsd:string"))
				{	soap_flag_Response--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterRemoveSequenceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterRemoveSequenceResponse, 0, sizeof(struct atxml__RegisterRemoveSequenceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterApplySequence(struct soap *soap, const struct atxml__RegisterApplySequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->ApplySequence);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterApplySequence(struct soap *soap, struct atxml__RegisterApplySequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->ApplySequence);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterApplySequence(struct soap *soap, const struct atxml__RegisterApplySequence *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterApplySequence);
	if (soap_out_atxml__RegisterApplySequence(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterApplySequence(struct soap *soap, const char *tag, int id, const struct atxml__RegisterApplySequence *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterApplySequence), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "ApplySequence", -1, &a->ApplySequence, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterApplySequence * SOAP_FMAC4 soap_get_atxml__RegisterApplySequence(struct soap *soap, struct atxml__RegisterApplySequence *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterApplySequence(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterApplySequence * SOAP_FMAC4 soap_in_atxml__RegisterApplySequence(struct soap *soap, const char *tag, struct atxml__RegisterApplySequence *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_ApplySequence = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterApplySequence *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterApplySequence, sizeof(struct atxml__RegisterApplySequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterApplySequence(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_ApplySequence && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "ApplySequence", &a->ApplySequence, "xsd:string"))
				{	soap_flag_ApplySequence--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterApplySequence *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterApplySequence, 0, sizeof(struct atxml__RegisterApplySequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterApplySequenceResponse(struct soap *soap, const struct atxml__RegisterApplySequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Response);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterApplySequenceResponse(struct soap *soap, struct atxml__RegisterApplySequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Response);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterApplySequenceResponse(struct soap *soap, const struct atxml__RegisterApplySequenceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterApplySequenceResponse);
	if (soap_out_atxml__RegisterApplySequenceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterApplySequenceResponse(struct soap *soap, const char *tag, int id, const struct atxml__RegisterApplySequenceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterApplySequenceResponse), type);
	if (a->Response)
		soap_element_result(soap, "Response");
	soap_out_xsd__string(soap, "Response", -1, &a->Response, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterApplySequenceResponse * SOAP_FMAC4 soap_get_atxml__RegisterApplySequenceResponse(struct soap *soap, struct atxml__RegisterApplySequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterApplySequenceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterApplySequenceResponse * SOAP_FMAC4 soap_in_atxml__RegisterApplySequenceResponse(struct soap *soap, const char *tag, struct atxml__RegisterApplySequenceResponse *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterApplySequenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterApplySequenceResponse, sizeof(struct atxml__RegisterApplySequenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterApplySequenceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Response", &a->Response, "xsd:string"))
				{	soap_flag_Response--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterApplySequenceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterApplySequenceResponse, 0, sizeof(struct atxml__RegisterApplySequenceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__ValidateRequirements(struct soap *soap, const struct atxml__ValidateRequirements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->TestRequirements);
	soap_serialize_xsd__string(soap, &a->Allocation);
	soap_embedded(soap, &a->BufferSize, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__ValidateRequirements(struct soap *soap, struct atxml__ValidateRequirements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->TestRequirements);
	soap_default_xsd__string(soap, &a->Allocation);
	soap_default_int(soap, &a->BufferSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__ValidateRequirements(struct soap *soap, const struct atxml__ValidateRequirements *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__ValidateRequirements);
	if (soap_out_atxml__ValidateRequirements(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__ValidateRequirements(struct soap *soap, const char *tag, int id, const struct atxml__ValidateRequirements *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__ValidateRequirements), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "TestRequirements", -1, &a->TestRequirements, "");
	soap_out_xsd__string(soap, "Allocation", -1, &a->Allocation, "");
	soap_out_int(soap, "BufferSize", -1, &a->BufferSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__ValidateRequirements * SOAP_FMAC4 soap_get_atxml__ValidateRequirements(struct soap *soap, struct atxml__ValidateRequirements *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__ValidateRequirements(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__ValidateRequirements * SOAP_FMAC4 soap_in_atxml__ValidateRequirements(struct soap *soap, const char *tag, struct atxml__ValidateRequirements *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_TestRequirements = 1, soap_flag_Allocation = 1, soap_flag_BufferSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__ValidateRequirements *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__ValidateRequirements, sizeof(struct atxml__ValidateRequirements), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__ValidateRequirements(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_TestRequirements && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "TestRequirements", &a->TestRequirements, "xsd:string"))
				{	soap_flag_TestRequirements--;
					continue;
				}
			if (soap_flag_Allocation && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Allocation", &a->Allocation, "xsd:string"))
				{	soap_flag_Allocation--;
					continue;
				}
			if (soap_flag_BufferSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BufferSize", &a->BufferSize, "xsd:int"))
				{	soap_flag_BufferSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_BufferSize > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__ValidateRequirements *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__ValidateRequirements, 0, sizeof(struct atxml__ValidateRequirements), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__ValidateRequirementsResponse(struct soap *soap, const struct atxml__ValidateRequirementsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Availability);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__ValidateRequirementsResponse(struct soap *soap, struct atxml__ValidateRequirementsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->Availability);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__ValidateRequirementsResponse(struct soap *soap, const struct atxml__ValidateRequirementsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__ValidateRequirementsResponse);
	if (soap_out_atxml__ValidateRequirementsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__ValidateRequirementsResponse(struct soap *soap, const char *tag, int id, const struct atxml__ValidateRequirementsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__ValidateRequirementsResponse), type);
	if (a->Availability)
		soap_element_result(soap, "Availability");
	soap_out_xsd__string(soap, "Availability", -1, &a->Availability, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__ValidateRequirementsResponse * SOAP_FMAC4 soap_get_atxml__ValidateRequirementsResponse(struct soap *soap, struct atxml__ValidateRequirementsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__ValidateRequirementsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__ValidateRequirementsResponse * SOAP_FMAC4 soap_in_atxml__ValidateRequirementsResponse(struct soap *soap, const char *tag, struct atxml__ValidateRequirementsResponse *a, const char *type)
{
	short soap_flag_Availability = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__ValidateRequirementsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__ValidateRequirementsResponse, sizeof(struct atxml__ValidateRequirementsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__ValidateRequirementsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Availability && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Availability", &a->Availability, "xsd:string"))
				{	soap_flag_Availability--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__ValidateRequirementsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__ValidateRequirementsResponse, 0, sizeof(struct atxml__ValidateRequirementsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterTSF(struct soap *soap, const struct atxml__RegisterTSF *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->TSFSignalDefinition);
	soap_serialize_xsd__string(soap, &a->TSFLibrary);
	soap_serialize_xsd__string(soap, &a->STDTSF);
	soap_serialize_xsd__string(soap, &a->STDBSC);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterTSF(struct soap *soap, struct atxml__RegisterTSF *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->TSFSignalDefinition);
	soap_default_xsd__string(soap, &a->TSFLibrary);
	soap_default_xsd__string(soap, &a->STDTSF);
	soap_default_xsd__string(soap, &a->STDBSC);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterTSF(struct soap *soap, const struct atxml__RegisterTSF *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterTSF);
	if (soap_out_atxml__RegisterTSF(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterTSF(struct soap *soap, const char *tag, int id, const struct atxml__RegisterTSF *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterTSF), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "TSFSignalDefinition", -1, &a->TSFSignalDefinition, "");
	soap_out_xsd__string(soap, "TSFLibrary", -1, &a->TSFLibrary, "");
	soap_out_xsd__string(soap, "STDTSF", -1, &a->STDTSF, "");
	soap_out_xsd__string(soap, "STDBSC", -1, &a->STDBSC, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterTSF * SOAP_FMAC4 soap_get_atxml__RegisterTSF(struct soap *soap, struct atxml__RegisterTSF *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterTSF(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterTSF * SOAP_FMAC4 soap_in_atxml__RegisterTSF(struct soap *soap, const char *tag, struct atxml__RegisterTSF *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_TSFSignalDefinition = 1, soap_flag_TSFLibrary = 1, soap_flag_STDTSF = 1, soap_flag_STDBSC = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterTSF *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterTSF, sizeof(struct atxml__RegisterTSF), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterTSF(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_TSFSignalDefinition && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "TSFSignalDefinition", &a->TSFSignalDefinition, "xsd:string"))
				{	soap_flag_TSFSignalDefinition--;
					continue;
				}
			if (soap_flag_TSFLibrary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "TSFLibrary", &a->TSFLibrary, "xsd:string"))
				{	soap_flag_TSFLibrary--;
					continue;
				}
			if (soap_flag_STDTSF && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "STDTSF", &a->STDTSF, "xsd:string"))
				{	soap_flag_STDTSF--;
					continue;
				}
			if (soap_flag_STDBSC && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "STDBSC", &a->STDBSC, "xsd:string"))
				{	soap_flag_STDBSC--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterTSF *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterTSF, 0, sizeof(struct atxml__RegisterTSF), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterTSFResponse(struct soap *soap, const struct atxml__RegisterTSFResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterTSFResponse(struct soap *soap, struct atxml__RegisterTSFResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterTSFResponse(struct soap *soap, const struct atxml__RegisterTSFResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterTSFResponse);
	if (soap_out_atxml__RegisterTSFResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterTSFResponse(struct soap *soap, const char *tag, int id, const struct atxml__RegisterTSFResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterTSFResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerToint(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterTSFResponse * SOAP_FMAC4 soap_get_atxml__RegisterTSFResponse(struct soap *soap, struct atxml__RegisterTSFResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterTSFResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterTSFResponse * SOAP_FMAC4 soap_in_atxml__RegisterTSFResponse(struct soap *soap, const char *tag, struct atxml__RegisterTSFResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterTSFResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterTSFResponse, sizeof(struct atxml__RegisterTSFResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterTSFResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterTSFResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterTSFResponse, 0, sizeof(struct atxml__RegisterTSFResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RetrieveTpsData(struct soap *soap, const struct atxml__RetrieveTpsData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RetrieveTpsData(struct soap *soap, struct atxml__RetrieveTpsData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RetrieveTpsData(struct soap *soap, const struct atxml__RetrieveTpsData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RetrieveTpsData);
	if (soap_out_atxml__RetrieveTpsData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RetrieveTpsData(struct soap *soap, const char *tag, int id, const struct atxml__RetrieveTpsData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RetrieveTpsData), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RetrieveTpsData * SOAP_FMAC4 soap_get_atxml__RetrieveTpsData(struct soap *soap, struct atxml__RetrieveTpsData *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RetrieveTpsData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RetrieveTpsData * SOAP_FMAC4 soap_in_atxml__RetrieveTpsData(struct soap *soap, const char *tag, struct atxml__RetrieveTpsData *a, const char *type)
{
	short soap_flag_Handle = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RetrieveTpsData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RetrieveTpsData, sizeof(struct atxml__RetrieveTpsData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RetrieveTpsData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RetrieveTpsData *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RetrieveTpsData, 0, sizeof(struct atxml__RetrieveTpsData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RetrieveTpsDataResponse(struct soap *soap, const struct atxml__RetrieveTpsDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->TpsName);
	soap_serialize_string(soap, &a->TpsVersion);
	soap_serialize_string(soap, &a->TpsFileName);
	soap_serialize_string(soap, &a->RecommendedAction);
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RetrieveTpsDataResponse(struct soap *soap, struct atxml__RetrieveTpsDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->TpsName);
	soap_default_string(soap, &a->TpsVersion);
	soap_default_string(soap, &a->TpsFileName);
	soap_default_string(soap, &a->RecommendedAction);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RetrieveTpsDataResponse(struct soap *soap, const struct atxml__RetrieveTpsDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RetrieveTpsDataResponse);
	if (soap_out_atxml__RetrieveTpsDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RetrieveTpsDataResponse(struct soap *soap, const char *tag, int id, const struct atxml__RetrieveTpsDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RetrieveTpsDataResponse), type);
	if (a->TpsName)
		soap_element_result(soap, "TpsName");
	soap_out_string(soap, "TpsName", -1, &a->TpsName, "");
	soap_out_string(soap, "TpsVersion", -1, &a->TpsVersion, "");
	soap_out_string(soap, "TpsFileName", -1, &a->TpsFileName, "");
	soap_out_string(soap, "RecommendedAction", -1, &a->RecommendedAction, "");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RetrieveTpsDataResponse * SOAP_FMAC4 soap_get_atxml__RetrieveTpsDataResponse(struct soap *soap, struct atxml__RetrieveTpsDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RetrieveTpsDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RetrieveTpsDataResponse * SOAP_FMAC4 soap_in_atxml__RetrieveTpsDataResponse(struct soap *soap, const char *tag, struct atxml__RetrieveTpsDataResponse *a, const char *type)
{
	short soap_flag_TpsName = 1, soap_flag_TpsVersion = 1, soap_flag_TpsFileName = 1, soap_flag_RecommendedAction = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RetrieveTpsDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RetrieveTpsDataResponse, sizeof(struct atxml__RetrieveTpsDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RetrieveTpsDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TpsName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TpsName", &a->TpsName, "xsd:string"))
				{	soap_flag_TpsName--;
					continue;
				}
			if (soap_flag_TpsVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TpsVersion", &a->TpsVersion, "xsd:string"))
				{	soap_flag_TpsVersion--;
					continue;
				}
			if (soap_flag_TpsFileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TpsFileName", &a->TpsFileName, "xsd:string"))
				{	soap_flag_TpsFileName--;
					continue;
				}
			if (soap_flag_RecommendedAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "RecommendedAction", &a->RecommendedAction, "xsd:string"))
				{	soap_flag_RecommendedAction--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RetrieveTpsDataResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RetrieveTpsDataResponse, 0, sizeof(struct atxml__RetrieveTpsDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterInterUsed(struct soap *soap, const struct atxml__RegisterInterUsed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->InterUsage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterInterUsed(struct soap *soap, struct atxml__RegisterInterUsed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_xsd__string(soap, &a->InterUsage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterInterUsed(struct soap *soap, const struct atxml__RegisterInterUsed *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterInterUsed);
	if (soap_out_atxml__RegisterInterUsed(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterInterUsed(struct soap *soap, const char *tag, int id, const struct atxml__RegisterInterUsed *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterInterUsed), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_xsd__string(soap, "InterUsage", -1, &a->InterUsage, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterInterUsed * SOAP_FMAC4 soap_get_atxml__RegisterInterUsed(struct soap *soap, struct atxml__RegisterInterUsed *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterInterUsed(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterInterUsed * SOAP_FMAC4 soap_in_atxml__RegisterInterUsed(struct soap *soap, const char *tag, struct atxml__RegisterInterUsed *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_InterUsage = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterInterUsed *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterInterUsed, sizeof(struct atxml__RegisterInterUsed), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterInterUsed(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_InterUsage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "InterUsage", &a->InterUsage, "xsd:string"))
				{	soap_flag_InterUsage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterInterUsed *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterInterUsed, 0, sizeof(struct atxml__RegisterInterUsed), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__RegisterInterUsedResponse(struct soap *soap, const struct atxml__RegisterInterUsedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__RegisterInterUsedResponse(struct soap *soap, struct atxml__RegisterInterUsedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__RegisterInterUsedResponse(struct soap *soap, const struct atxml__RegisterInterUsedResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__RegisterInterUsedResponse);
	if (soap_out_atxml__RegisterInterUsedResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__RegisterInterUsedResponse(struct soap *soap, const char *tag, int id, const struct atxml__RegisterInterUsedResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__RegisterInterUsedResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerToint(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__RegisterInterUsedResponse * SOAP_FMAC4 soap_get_atxml__RegisterInterUsedResponse(struct soap *soap, struct atxml__RegisterInterUsedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__RegisterInterUsedResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__RegisterInterUsedResponse * SOAP_FMAC4 soap_in_atxml__RegisterInterUsedResponse(struct soap *soap, const char *tag, struct atxml__RegisterInterUsedResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__RegisterInterUsedResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__RegisterInterUsedResponse, sizeof(struct atxml__RegisterInterUsedResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__RegisterInterUsedResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__RegisterInterUsedResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__RegisterInterUsedResponse, 0, sizeof(struct atxml__RegisterInterUsedResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__Close(struct soap *soap, const struct atxml__Close *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Handle, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->ProcUuid);
	soap_embedded(soap, &a->Pid, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__Close(struct soap *soap, struct atxml__Close *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Handle);
	soap_default_string(soap, &a->ProcUuid);
	soap_default_int(soap, &a->Pid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__Close(struct soap *soap, const struct atxml__Close *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__Close);
	if (soap_out_atxml__Close(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__Close(struct soap *soap, const char *tag, int id, const struct atxml__Close *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__Close), type);
	soap_out_int(soap, "Handle", -1, &a->Handle, "");
	soap_out_string(soap, "ProcUuid", -1, &a->ProcUuid, "");
	soap_out_int(soap, "Pid", -1, &a->Pid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__Close * SOAP_FMAC4 soap_get_atxml__Close(struct soap *soap, struct atxml__Close *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__Close(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__Close * SOAP_FMAC4 soap_in_atxml__Close(struct soap *soap, const char *tag, struct atxml__Close *a, const char *type)
{
	short soap_flag_Handle = 1, soap_flag_ProcUuid = 1, soap_flag_Pid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__Close *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__Close, sizeof(struct atxml__Close), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__Close(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Handle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Handle", &a->Handle, "xsd:int"))
				{	soap_flag_Handle--;
					continue;
				}
			if (soap_flag_ProcUuid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ProcUuid", &a->ProcUuid, "xsd:string"))
				{	soap_flag_ProcUuid--;
					continue;
				}
			if (soap_flag_Pid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Pid", &a->Pid, "xsd:int"))
				{	soap_flag_Pid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Handle > 0 || soap_flag_Pid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__Close *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__Close, 0, sizeof(struct atxml__Close), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__CloseResponse(struct soap *soap, const struct atxml__CloseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__CloseResponse(struct soap *soap, struct atxml__CloseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__CloseResponse(struct soap *soap, const struct atxml__CloseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__CloseResponse);
	if (soap_out_atxml__CloseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__CloseResponse(struct soap *soap, const char *tag, int id, const struct atxml__CloseResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__CloseResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerToint(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__CloseResponse * SOAP_FMAC4 soap_get_atxml__CloseResponse(struct soap *soap, struct atxml__CloseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__CloseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__CloseResponse * SOAP_FMAC4 soap_in_atxml__CloseResponse(struct soap *soap, const char *tag, struct atxml__CloseResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__CloseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__CloseResponse, sizeof(struct atxml__CloseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__CloseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__CloseResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__CloseResponse, 0, sizeof(struct atxml__CloseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__Initialize(struct soap *soap, const struct atxml__Initialize *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ProcType);
	soap_serialize_string(soap, &a->ProcUuid);
	soap_embedded(soap, &a->Pid, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__Initialize(struct soap *soap, struct atxml__Initialize *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ProcType);
	soap_default_string(soap, &a->ProcUuid);
	soap_default_int(soap, &a->Pid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__Initialize(struct soap *soap, const struct atxml__Initialize *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__Initialize);
	if (soap_out_atxml__Initialize(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__Initialize(struct soap *soap, const char *tag, int id, const struct atxml__Initialize *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__Initialize), type);
	soap_out_string(soap, "ProcType", -1, &a->ProcType, "");
	soap_out_string(soap, "ProcUuid", -1, &a->ProcUuid, "");
	soap_out_int(soap, "Pid", -1, &a->Pid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__Initialize * SOAP_FMAC4 soap_get_atxml__Initialize(struct soap *soap, struct atxml__Initialize *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__Initialize(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__Initialize * SOAP_FMAC4 soap_in_atxml__Initialize(struct soap *soap, const char *tag, struct atxml__Initialize *a, const char *type)
{
	short soap_flag_ProcType = 1, soap_flag_ProcUuid = 1, soap_flag_Pid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__Initialize *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__Initialize, sizeof(struct atxml__Initialize), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__Initialize(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ProcType", &a->ProcType, "xsd:string"))
				{	soap_flag_ProcType--;
					continue;
				}
			if (soap_flag_ProcUuid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ProcUuid", &a->ProcUuid, "xsd:string"))
				{	soap_flag_ProcUuid--;
					continue;
				}
			if (soap_flag_Pid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Pid", &a->Pid, "xsd:int"))
				{	soap_flag_Pid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Pid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__Initialize *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__Initialize, 0, sizeof(struct atxml__Initialize), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_atxml__InitializeResponse(struct soap *soap, const struct atxml__InitializeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_atxml__InitializeResponse(struct soap *soap, struct atxml__InitializeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_atxml__InitializeResponse(struct soap *soap, const struct atxml__InitializeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_atxml__InitializeResponse);
	if (soap_out_atxml__InitializeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_atxml__InitializeResponse(struct soap *soap, const char *tag, int id, const struct atxml__InitializeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_atxml__InitializeResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerToint(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct atxml__InitializeResponse * SOAP_FMAC4 soap_get_atxml__InitializeResponse(struct soap *soap, struct atxml__InitializeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_atxml__InitializeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct atxml__InitializeResponse * SOAP_FMAC4 soap_in_atxml__InitializeResponse(struct soap *soap, const char *tag, struct atxml__InitializeResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct atxml__InitializeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_atxml__InitializeResponse, sizeof(struct atxml__InitializeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_atxml__InitializeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct atxml__InitializeResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_atxml__InitializeResponse, 0, sizeof(struct atxml__InitializeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__string(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (soap_out_xsd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of soapC.cpp */
